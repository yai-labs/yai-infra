name: reusable-validate-pr-metadata

on:
  workflow_call:
    inputs:
      pr_body:
        required: true
        type: string

jobs:
  metadata:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate PR metadata fields and semantics
        uses: actions/github-script@v7
        env:
          PR_BODY: ${{ inputs.pr_body }}
        with:
          script: |
            const body = process.env.PR_BODY || "";

            function fail(msg) {
              core.setFailed(msg);
            }

            const required = [
              "Issue-ID:",
              "MP-ID:",
              "Runbook:",
              "Base-Commit:",
              "Classification:",
              "Compatibility:",
              "## Evidence",
              "## Commands run"
            ];
            const missing = required.filter((k) => !body.includes(k));
            if (missing.length) return fail(`Missing required PR fields: ${missing.join(", ")}`);

            const banned = [
              "#<issue-number>", "<issue-id>", "<40-char-sha>", "MP-<TRACK>-<X.Y.Z>",
              "docs/runbooks/<name>.md#<anchor>", "<one paragraph>",
              "<what doc/policy changes and why>", "<case 1>", "# exact commands"
            ];
            const unresolved = banned.filter((x) => body.includes(x));
            if (unresolved.length) return fail(`Unresolved placeholders in PR body: ${unresolved.join(", ")}`);
            if (/^\s*-\s+\.\.\.\s*$/m.test(body)) return fail("Placeholder bullets ('- ...') are not allowed.");

            const extract = (label) => {
              const re = new RegExp(`${label}\\s*:\\s*([^\\n\\r]+)`, "i");
              const m = body.match(re);
              return m ? m[1].trim() : "";
            };

            const issue = extract("Issue-ID");
            if (!/^#\d+$/.test(issue) && !/^N\/A$/i.test(issue)) return fail("Issue-ID must be #<number> or N/A.");

            const mp = extract("MP-ID");
            if (!/^N\/A$/i.test(mp) && !/^MP-[A-Z0-9-]+-\d+\.\d+\.\d+$/.test(mp)) {
              return fail("MP-ID must be MP-<TRACK>-<X.Y.Z> or N/A.");
            }

            const runbook = extract("Runbook");
            if (!/^N\/A$/i.test(runbook) && !/^docs\/runbooks\/.+\.md#.+$/.test(runbook)) {
              return fail("Runbook must be docs/runbooks/<name>.md#<anchor> or N/A.");
            }

            const base = extract("Base-Commit");
            if (!/^[0-9a-f]{40}$/i.test(base)) return fail("Base-Commit must be a 40-char SHA.");

            const evidenceMatch = body.match(/## Evidence\s*([\s\S]*?)(?:\n##\s|$)/i);
            const evidence = evidenceMatch ? evidenceMatch[1].trim() : "";
            if (!evidence) return fail("Evidence section cannot be empty.");
            if (/(\bTODO\b|\bTBD\b|to be done|lorem ipsum)/i.test(evidence)) {
              return fail("Evidence contains placeholder/TODO text.");
            }
            if (!/-\s+Positive:\s*[\s\S]*-\s+Negative:/i.test(evidence)) {
              return fail("Evidence must include Positive and Negative subsections.");
            }

            const cmdMatch = body.match(/## Commands run\s*[\s\S]*?```bash\s*([\s\S]*?)```/i);
            if (!cmdMatch) return fail("Commands run must include a bash fenced code block.");
            const runnable = cmdMatch[1]
              .split("\n")
              .map((x) => x.trim())
              .filter((x) => x.length > 0 && !x.startsWith("#"));
            if (runnable.length === 0) return fail("Commands run must include at least one executable command.");

            core.info("PR metadata validation passed.");

      - name: Validate runbook path and anchor (if provided)
        shell: bash
        env:
          PR_BODY: ${{ inputs.pr_body }}
        run: |
          set -euo pipefail
          BODY_FILE="$(mktemp)"
          printf '%s\n' "$PR_BODY" > "$BODY_FILE"

          runbook="$(sed -nE 's/.*Runbook:[[:space:]]*([^[:space:]].*)/\1/p' "$BODY_FILE" | head -n1 | tr -d '\r')"
          if [[ -z "$runbook" || "$runbook" =~ ^N/A$|^N\/A$ ]]; then
            echo "Runbook is N/A: skipping file/anchor validation"
            exit 0
          fi

          file="${runbook%%#*}"
          anchor="${runbook#*#}"
          if [[ "$file" == "$anchor" || -z "$anchor" ]]; then
            echo "Runbook anchor missing in: $runbook" >&2
            exit 1
          fi

          if [[ ! -f "$file" ]]; then
            echo "Runbook file not found: $file" >&2
            exit 1
          fi

          if ! grep -Eq "id=\"$anchor\"|\(#$anchor\)|^#+[[:space:]].*\{#$anchor\}" "$file"; then
            echo "Runbook anchor not found in $file: #$anchor" >&2
            exit 1
          fi

          echo "Runbook link validated: $runbook"
