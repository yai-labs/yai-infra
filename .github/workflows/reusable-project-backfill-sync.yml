name: reusable-project-backfill-sync

on:
  workflow_call:
    inputs:
      project_owner:
        description: Project owner/org login.
        required: false
        type: string
        default: "yai-labs"
      project_number:
        description: Project number.
        required: false
        type: number
        default: 5
      default_phase:
        description: Fallback phase when milestone is absent.
        required: false
        type: string
        default: "0.1.1"
      default_track:
        description: Fallback track when track label is absent.
        required: false
        type: string
        default: "release-hardening"
      default_assignee:
        description: Default assignee login.
        required: false
        type: string
        default: "francescomaiomascio"
      allowed_tracks:
        description: Comma-separated track names allowed by target project.
        required: false
        type: string
        default: ""
    secrets:
      project_token:
        required: false

permissions:
  contents: read
  issues: write
  pull-requests: write
  repository-projects: write

jobs:
  backfill:
    concurrency:
      group: reusable-project-backfill-sync-${{ github.repository }}
      cancel-in-progress: true
    runs-on: ubuntu-latest
    steps:
      - name: Backfill project fields and labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.project_token != '' && secrets.project_token || secrets.YAI_PROJECT_TOKEN != '' && secrets.YAI_PROJECT_TOKEN || github.token }}
          script: |
            const OWNER = "${{ inputs.project_owner }}" || "yai-labs";
            const PROJECT_NUMBER = Number("${{ inputs.project_number }}" || "5");
            const DEFAULT_PHASE = "${{ inputs.default_phase }}" || "0.1.1";
            const DEFAULT_TRACK = "${{ inputs.default_track }}" || "release-hardening";
            const DEFAULT_ASSIGNEE = "${{ inputs.default_assignee }}" || "francescomaiomascio";
            const ALLOWED_TRACKS = ("${{ inputs.allowed_tracks }}" || "")
              .split(",")
              .map((x) => x.trim())
              .filter(Boolean);

            const normalize = (s) => (s || "").toLowerCase().replace(/[^a-z0-9]+/g, "");
            const isAllowedTrack = (t) => !ALLOWED_TRACKS.length || ALLOWED_TRACKS.includes(t);
            const resolveOptionId = (field, desired, aliases = []) => {
              if (!field || !field.options) return null;
              const candidates = [desired, ...aliases].map(normalize).filter(Boolean);
              for (const cand of candidates) {
                const opt = field.options.find((o) => normalize(o.name) === cand);
                if (opt) return opt.id;
              }
              return null;
            };

            const projectRes = await github.graphql(
              `
              query($owner:String!,$number:Int!){
                organization(login:$owner){
                  projectV2(number:$number){
                    id
                    fields(first:100){
                      nodes{
                        ... on ProjectV2FieldCommon{ id name }
                        ... on ProjectV2SingleSelectField{ id name options{ id name } }
                      }
                    }
                  }
                }
              }
              `,
              { owner: OWNER, number: PROJECT_NUMBER }
            );

            const project = projectRes.organization?.projectV2;
            if (!project) {
              core.setFailed(`Project not found: ${OWNER}#${PROJECT_NUMBER}`);
              return;
            }

            const fields = project.fields.nodes || [];
            const byName = (name) => fields.find((f) => f?.name === name);

            const setSingle = async (itemId, fieldName, value, aliases = []) => {
              const field = byName(fieldName);
              const optionId = resolveOptionId(field, value, aliases);
              if (!field || !optionId) return;
              await github.graphql(
                `
                mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$optionId }
                  }){ projectV2Item{ id } }
                }
                `,
                { projectId: project.id, itemId, fieldId: field.id, optionId }
              );
            };

            const setDate = async (itemId, date) => {
              const field = byName("Target Date");
              if (!field) return;
              if (!date) {
                await github.graphql(
                  `
                  mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!){
                    clearProjectV2ItemFieldValue(input:{
                      projectId:$projectId,
                      itemId:$itemId,
                      fieldId:$fieldId
                    }){ projectV2Item{ id } }
                  }
                  `,
                  { projectId: project.id, itemId, fieldId: field.id }
                );
                return;
              }
              await github.graphql(
                `
                mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$date:Date!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ date:$date }
                  }){ projectV2Item{ id } }
                }
                `,
                { projectId: project.id, itemId, fieldId: field.id, date }
              );
            };

            const inferTypeLabel = (title, body, isIssue) => {
              const txt = `${title || ""}\n${body || ""}`.toLowerCase();
              if (/\bci\b|workflow|github actions?|pipeline/.test(txt)) return "type:ci";
              if (/tools?|script|schema|lint|verify|wrapper/.test(txt)) return "type:tooling";
              if (/migration|cutover|stabilization|hardening/.test(txt)) return "type:migration";
              if (/docs?|runbook|adr|rfc|proposal|program|milestone/.test(txt)) return "type:docs";
              return isIssue ? "type:governance" : "type:ci";
            };

            const inferTrack = (labels, title, body, milestoneTitle) => {
              const labelTrack = labels.find((x) => x.startsWith("track:"));
              const fromLabel = labelTrack ? labelTrack.replace(/^track:/, "") : null;
              if (fromLabel && isAllowedTrack(fromLabel)) return fromLabel;

              const blob = `${title || ""}\n${body || ""}\n${milestoneTitle || ""}`.toLowerCase();
              const candidates = [
                "contract-baseline-lock",
                "specs-refactor-foundation",
                "audit-convergence",
                "release-hardening",
                "cutover-wave",
                "infra-bootstrap",
                "stabilization",
              ];
              for (const c of candidates) {
                if (blob.includes(c) && isAllowedTrack(c)) return c;
              }
              return DEFAULT_TRACK;
            };

            const items = [];
            let after = null;
            do {
              const page = await github.graphql(
                `
                query($project:ID!,$after:String){
                  node(id:$project){
                    ... on ProjectV2{
                      items(first:100, after:$after){
                        pageInfo{ hasNextPage endCursor }
                        nodes{
                          id
                          content{
                            __typename
                            ... on Issue{
                              number title body state closedAt
                              repository{ name owner{ login } nameWithOwner }
                              milestone{ title dueOn }
                              labels(first:50){ nodes{ name } }
                              assignees(first:10){ nodes{ login } }
                            }
                            ... on PullRequest{
                              number title body state merged mergedAt closedAt
                              repository{ name owner{ login } nameWithOwner }
                              milestone{ title dueOn }
                              labels(first:50){ nodes{ name } }
                              assignees(first:10){ nodes{ login } }
                            }
                          }
                        }
                      }
                    }
                  }
                }
                `,
                { project: project.id, after }
              );
              const conn = page.node?.items;
              for (const n of conn?.nodes || []) items.push(n);
              after = conn?.pageInfo?.hasNextPage ? conn.pageInfo.endCursor : null;
            } while (after);

            let processed = 0;
            for (const item of items) {
              const c = item.content;
              if (!c || (c.__typename !== "Issue" && c.__typename !== "PullRequest")) continue;
              if (c.repository?.nameWithOwner !== `${context.repo.owner}/${context.repo.repo}`) continue;

              const isIssue = c.__typename === "Issue";
              const labels = (c.labels?.nodes || []).map((x) => (x.name || "").toLowerCase());
              const track = inferTrack(labels, c.title, c.body, c.milestone?.title || "");
              const typeLabel = inferTypeLabel(c.title, c.body, isIssue);

              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: c.number,
                  labels: [`track:${track}`, typeLabel],
                });
              } catch (err) {
                core.warning(`Label sync skipped for #${c.number}: ${err.message}`);
              }

              try {
                const current = (c.assignees?.nodes || []).map((a) => a.login);
                if (!current.includes(DEFAULT_ASSIGNEE)) {
                  await github.rest.issues.addAssignees({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: c.number,
                    assignees: [DEFAULT_ASSIGNEE],
                  });
                }
              } catch (err) {
                core.warning(`Assignee sync skipped for #${c.number}: ${err.message}`);
              }

              const stateClosed = c.state === "CLOSED" || c.state === "MERGED";
              const merged = !isIssue ? !!c.merged : false;
              const isRunbook = isIssue && (c.title || "").toLowerCase().startsWith("runbook:");
              const isMpClosure = isIssue && (c.title || "").toLowerCase().startsWith("mp-closure:");

              const status = stateClosed ? "Done" : (isRunbook ? "Todo" : "In Progress");
              const gate = stateClosed ? (isIssue || merged ? "Passed" : "Failed") : (isRunbook ? "Not Started" : "Running");
              const workType = isIssue ? (isMpClosure ? "MP Closure" : "Issue") : "PR";
              const phaseType = isIssue
                ? (isMpClosure ? "MP Closure" : (isRunbook ? "Phase Issue" : "Execution Issue"))
                : "PR";
              const phase = (() => {
                const m = (c.milestone?.title || "").match(/\b0\.\d+\.\d+\b/);
                return m ? m[0] : DEFAULT_PHASE;
              })();
              const klass = labels.includes("class:b") || `${c.title || ""} ${c.body || ""}`.toLowerCase().includes("blocker") ? "B" : "A";

              const closedDateRaw = isIssue ? c.closedAt : (c.mergedAt || c.closedAt);
              const targetRaw = stateClosed ? (closedDateRaw || null) : (c.milestone?.dueOn || null);
              const targetDate = targetRaw ? new Date(targetRaw).toISOString().slice(0, 10) : new Date().toISOString().slice(0, 10);

              await setSingle(item.id, "Status", status, [stateClosed ? "Closed" : "Open"]);
              await setSingle(item.id, "Gate Status", gate);
              await setSingle(item.id, "Phase", phase);
              await setSingle(item.id, "Track", track, [track.replace(/-/g, " "), DEFAULT_TRACK]);
              await setSingle(item.id, "Work Type", workType);
              await setSingle(item.id, "Type", isIssue ? "Issue" : "PR", [isIssue ? "Task" : "Change"]);
              await setSingle(item.id, "Phase Type", phaseType);
              await setSingle(item.id, "Class", klass);
              await setDate(item.id, targetDate);
              processed += 1;
            }

            core.info(`Project backfill completed. Items processed: ${processed}`);
