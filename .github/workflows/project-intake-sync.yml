name: project-intake-sync

on:
  issues:
    types: [opened, reopened, edited, milestoned, demilestoned, labeled, unlabeled]
  pull_request:
    types: [opened, reopened, edited, synchronize, labeled, unlabeled, milestoned, demilestoned]

jobs:
  intake:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
      pull-requests: write
      repository-projects: write
    steps:
      - name: Auto-assign and sync intake fields
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.YAI_PROJECT_TOKEN != '' && secrets.YAI_PROJECT_TOKEN || github.token }}
          script: |
            const OWNER = "yai-labs";
            const PROJECT_NUMBER = 5;
            const DEFAULT_ASSIGNEE = "francescomaiomascio";
            const DEFAULT_PHASE = "0.1.1";
            const DEFAULT_TRACK = "release-hardening";

            const isIssue = context.eventName === "issues";
            const node = isIssue ? context.payload.issue : context.payload.pull_request;
            if (!node) return;

            const number = node.number;
            const contentId = node.node_id;
            const labels = (node.labels || []).map((l) => (l.name || "").toLowerCase());
            let milestone = node.milestone || null;
            const textBlob = `${node.title || ""}\n${node.body || ""}`;
            const phaseToken = (textBlob.match(/\b0\.\d+\.\d+\b/) || [null])[0] || DEFAULT_PHASE;

            // Auto-attach milestone if missing, based on phase token.
            if (!milestone) {
              try {
                const ms = await github.rest.issues.listMilestones({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: "all",
                  per_page: 100,
                });
                const candidates = (ms.data || []).filter((m) => (m.title || "").includes(phaseToken));
                if (candidates.length > 0) {
                  candidates.sort((a, b) => {
                    const sa = a.state === "open" ? 0 : 1;
                    const sb = b.state === "open" ? 0 : 1;
                    if (sa !== sb) return sa - sb;
                    const da = a.due_on || "9999-12-31T00:00:00Z";
                    const db = b.due_on || "9999-12-31T00:00:00Z";
                    return da.localeCompare(db);
                  });
                  const chosen = candidates[0];
                  await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: number,
                    milestone: chosen.number,
                  });
                  milestone = {
                    title: chosen.title,
                    due_on: chosen.due_on,
                  };
                }
              } catch (err) {
                core.warning(`Auto-milestone skipped: ${err.message}`);
              }
            }

            const phaseFromMilestone = (() => {
              if (!milestone || !milestone.title) return phaseToken;
              const m = milestone.title.match(/\b0\.\d+\.\d+\b/);
              return m ? m[0] : DEFAULT_PHASE;
            })();
            const phase = phaseFromMilestone;
            const isClosed = node.state === "closed";
            const closedDate = isIssue ? node.closed_at : (node.merged_at || node.closed_at);
            const targetDateRaw = isClosed
              ? (closedDate || milestone?.due_on || null)
              : (milestone?.due_on || null);
            const targetDate = targetDateRaw ? new Date(targetDateRaw).toISOString().slice(0, 10) : null;

            const track = (() => {
              const ms = (milestone?.title || "").toLowerCase();
              const tt = (node.title || "").toLowerCase();
              const bb = `${tt}\n${ms}`;
              if (bb.includes("bootstrap")) return "infra-bootstrap";
              if (bb.includes("infra-cutover") || bb.includes("[cutover]")) return "cutover-wave";
              if (bb.includes("stabilization")) return "stabilization";
              if (labels.includes("track:infra-bootstrap")) return "infra-bootstrap";
              if (labels.includes("track:cutover-wave")) return "cutover-wave";
              if (labels.includes("track:stabilization")) return "stabilization";
              if (labels.includes("track:release-hardening")) return "release-hardening";
              return DEFAULT_TRACK;
            })();

            const className = (() => {
              if (!isIssue) return "B";
              const t = (node.title || "").toLowerCase();
              return t.startsWith("[infra]") ? "A" : "B";
            })();

            const merged = !isIssue ? !!node.merged : false;
            const statusName = isClosed ? "Done" : "In Progress";
            const gateName = isClosed ? (isIssue || merged ? "Passed" : "Failed") : "Running";
            const workTypeName = isIssue ? "Issue" : "PR";
            const phaseTypeName = isIssue ? "Execution Issue" : "PR";

            // Auto-assign owner on intake.
            try {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: number,
                assignees: [DEFAULT_ASSIGNEE],
              });
            } catch (err) {
              core.warning(`Auto-assign skipped: ${err.message}`);
            }

            const projectRes = await github.graphql(
              `
              query($owner:String!,$number:Int!){
                organization(login:$owner){
                  projectV2(number:$number){
                    id
                    fields(first:50){
                      nodes{
                        ... on ProjectV2FieldCommon{ id name }
                        ... on ProjectV2SingleSelectField{
                          id
                          name
                          options{ id name }
                        }
                      }
                    }
                  }
                }
              }
              `,
              { owner: OWNER, number: PROJECT_NUMBER }
            );
            const project = projectRes.organization?.projectV2;
            if (!project) {
              core.setFailed(`Project not found: ${OWNER}#${PROJECT_NUMBER}`);
              return;
            }

            const itemRes = await github.graphql(
              `
              mutation($projectId:ID!,$contentId:ID!){
                addProjectV2ItemById(input:{ projectId:$projectId, contentId:$contentId }){
                  item{ id }
                }
              }
              `,
              { projectId: project.id, contentId }
            ).catch(() => null);

            const getItemsRes = await github.graphql(
              `
              query($id:ID!){
                node(id:$id){
                  ... on Issue{
                    projectItems(first:50){ nodes{ id project{ id } } }
                  }
                  ... on PullRequest{
                    projectItems(first:50){ nodes{ id project{ id } } }
                  }
                }
              }
              `,
              { id: contentId }
            );
            const items = getItemsRes.node?.projectItems?.nodes || [];
            const item = items.find((i) => i.project?.id === project.id) || itemRes?.addProjectV2ItemById?.item;
            if (!item) {
              core.setFailed(`Unable to find/create project item for #${number}.`);
              return;
            }

            const fields = project.fields.nodes || [];
            const fieldByName = (name) => fields.find((f) => f?.name === name);
            const optionId = (fieldName, optName) => {
              const f = fieldByName(fieldName);
              return (f?.options || []).find((o) => o.name === optName)?.id || null;
            };

            const updates = [
              ["Status", statusName],
              ["Gate Status", gateName],
              ["Phase", phase],
              ["Track", track],
              ["Work Type", workTypeName],
              ["Type", workTypeName],
              ["Phase Type", phaseTypeName],
              ["Class", className],
            ];

            for (const [fname, oname] of updates) {
              const field = fieldByName(fname);
              const opt = optionId(fname, oname);
              if (!field || !opt) continue;
              await github.graphql(
                `
                mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$optionId:String!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ singleSelectOptionId:$optionId }
                  }){ projectV2Item{ id } }
                }
                `,
                { projectId: project.id, itemId: item.id, fieldId: field.id, optionId: opt }
              );
            }

            const targetField = fieldByName("Target Date");
            if (targetField && targetDate) {
              await github.graphql(
                `
                mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!,$date:Date!){
                  updateProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId,
                    value:{ date:$date }
                  }){ projectV2Item{ id } }
                }
                `,
                { projectId: project.id, itemId: item.id, fieldId: targetField.id, date: targetDate }
              );
            } else if (targetField) {
              await github.graphql(
                `
                mutation($projectId:ID!,$itemId:ID!,$fieldId:ID!){
                  clearProjectV2ItemFieldValue(input:{
                    projectId:$projectId,
                    itemId:$itemId,
                    fieldId:$fieldId
                  }){ projectV2Item{ id } }
                }
                `,
                { projectId: project.id, itemId: item.id, fieldId: targetField.id }
              );
            }

            // Optional parent-child linkage: include "Parent-Issue: #<num>" in issue body.
            if (isIssue) {
              const body = node.body || "";
              const parentMatch = body.match(/Parent-Issue:\s*#(\d+)/i);
              if (parentMatch) {
                const parentNumber = Number(parentMatch[1]);
                try {
                  const parentIssue = await github.rest.issues.get({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: parentNumber,
                  });
                  await github.graphql(
                    `
                    mutation($parent:ID!,$child:ID!){
                      addSubIssue(input:{ issueId:$parent, subIssueId:$child }){
                        issue{ id }
                      }
                    }
                    `,
                    { parent: parentIssue.data.node_id, child: node.node_id }
                  );
                } catch (err) {
                  core.warning(`Parent-Issue link skipped: ${err.message}`);
                }
              }
            }

            core.info(
              `Intake synced for #${number}: assignee=${DEFAULT_ASSIGNEE}, status=${statusName}, gate=${gateName}, phase=${phase}, track=${track}.`
            );
